/*
 * <p>Title: Assembler.java</p>
 * <p>Description: </p>
 * <p>Copyright: Copyright (c) 2005</p>
 * <p>Company: NASA Ames Research Center</p>
 * @author Ronald Mak & Luca Severini <lucaseverini@mac.com>
 * @version 2.0
 */


package rope1401;

import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.prefs.Preferences;
import javax.swing.JOptionPane;

class Assembler
{
	// private static String sourceName;
	// private static String sourcePath;
    private static BufferedReader stdout;
    private static Process process;
	private static final Preferences userPrefs = Preferences.userRoot();

    static void setPaths(String sourceName, String sourcePath)
    {
		// Assembler.sourceName = sourceName;
		// Assembler.sourcePath = sourcePath;
    }

    static boolean version()
    {		
		String[] args = new String[2];
		args[0] = AssemblerOptions.assemblerPath;
		args[1] = "-V";

        try 
		{
            process = Runtime.getRuntime().exec(args);
            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));
 
			process = null;
			
			return true;
		}
        catch(IOException ex) 
		{
            ex.printStackTrace();
			
			return false;
        }
    }

    static boolean assemble()
    {
        try 
		{
			Simulator.kill();
			
			File objFile = new File(AssemblerOptions.objectPath);
			File tapeFile = new File(AssemblerOptions.tapePath);
			File diagFile = new File(AssemblerOptions.diagnosticPath);
			File listFile = new File(AssemblerOptions.listingPath);
			File outFile = new File(RopeUtils.removeExtension(AssemblerOptions.sourcePath) + ".out");
			
			// Remove all old files generated by assembler process
			RopeUtils.renameAndDelete(objFile);
			RopeUtils.renameAndDelete(tapeFile);
			RopeUtils.renameAndDelete(diagFile);		
			RopeUtils.renameAndDelete(listFile);
			RopeUtils.renameAndDelete(outFile);
						
			if(AssemblerOptions.tape /* && 
			   AssemblerOptions.tapeEncoding && 
			   !AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.deckEncodingChoice) */)
			{
				// Generate assembly and tape first...
				if(buildTape())		
				{
					addRowToTape(AssemblerOptions.tapePath, "~L038I9C~N000~B007~TAPE DCW @TAPE@ ~}");
				
					if(AssemblerOptions.tape && AssemblerOptions.convertTapeForTapeSimulator)
					{
						RopeUtils.convertTape(AssemblerOptions.tapePath, AssemblerOptions.ENCODING_SIMH, AssemblerOptions.ENCODING_A);
					}

					// ...then generate deck
					buildDeck();
				}
			}
			else
			{
				// Generate the assembly 
				if(buildAssembly())
				{
					addRowToTape(AssemblerOptions.tapePath, "~L038I9C~N000~B007~TAPE DCW @TAPE@ ~}");
				
					if(AssemblerOptions.tape && AssemblerOptions.convertTapeForTapeSimulator)
					{
						RopeUtils.convertTape(AssemblerOptions.tapePath, AssemblerOptions.ENCODING_SIMH, AssemblerOptions.ENCODING_A);
					}
				}
			}
						
			// Remove empty files...
			if(objFile.exists() && objFile.length() == 0)
			{
				objFile.delete();
			}
			if(tapeFile.exists() && tapeFile.length() == 0)
			{
				tapeFile.delete();
			}
			if(diagFile.exists() && diagFile.length() == 0)
			{
				diagFile.delete();
			}
			if(listFile.exists() && listFile.length() == 0)
			{
				listFile.delete();
			}
			if(outFile.exists() && outFile.length() == 0)
			{
				outFile.delete();
			}
			
			if (userPrefs.getBoolean("convertPlusToAmpersand", true))
			{
				convertAmpToPlusInList(listFile.getPath());
			}

			process = null;
			
			return true;
        }
        catch(Exception ex) 
		{
            ex.printStackTrace();
			
			return false;
        }
    }

    static String output()
    {
        try 
		{
            String line = stdout.readLine();
            if (line == null) 
			{
                stdout.close();
            }

            return line;
        }
        catch (IOException ex) 
		{
            ex.printStackTrace();
			
            return null;
        }
    }

	static void kill()
    {
        if (process != null)
		{
            process.destroy();            
            System.out.println("Assembler killed");
        }
    }
	
	// From Stan Paddock request
	// Replace '&' with '+' in code positions from 22 until comment or EOL		
	static void convertPlusToAmpInSource(String sourcePath)
	{
		try
		{
			BufferedReader reader = new BufferedReader(new FileReader(sourcePath));
			
			List<String> lines = new ArrayList<String>();
			String line = null;
			while ((line = reader.readLine()) != null)
			{
				lines.add(line);
			}
			reader.close();
			
			String[] strings = lines.toArray(new String[lines.size()]);
			
			BufferedWriter writer = new BufferedWriter(new FileWriter(sourcePath));
						
			for (int strIdx = 0; strIdx < strings.length; strIdx++)
			{
				String str = strings[strIdx];
				int strLen = str.length();
				if (strLen > 6)
				{
					char chars[] = str.toCharArray();
					if (chars[5] != '*')
					{
						int adjacentSpaces = 0;
						for (int chIdx = 6; chIdx < strLen; chIdx++)
						{
							adjacentSpaces = (chIdx >= 20 && chars[chIdx] == ' ' ? adjacentSpaces + 1 : 0);
							if (adjacentSpaces == 2)
							{
								break; // Now we are in comment space...
							}
							
							if (chars[chIdx] == '+')
							{
								chars[chIdx] = '&';
							}
						}
						
						str = new String(chars);
					}				
				}
				
				writer.write(str);
				writer.newLine();
			}
			 
			writer.close(); 
		}
        catch(Exception ex)
        {
            ex.printStackTrace();
        }		
	}
	
	static void convertAmpToPlusInList(String listPath)
	{
		File listFile = new File(listPath);
		if (!listFile.exists())
		{
			return;
		}
		
		try
		{
			BufferedReader reader = new BufferedReader(new FileReader(listPath));
			
			List<String> lines = new ArrayList<String>();
			String line = null;
			while ((line = reader.readLine()) != null)
			{
				lines.add(line);
			}
			reader.close();
			
			String[] strings = lines.toArray(new String[lines.size()]);
			
			BufferedWriter writer = new BufferedWriter(new FileWriter(listPath));
						
			for (int strIdx = 0; strIdx < strings.length; strIdx++)
			{
				String str = strings[strIdx];
				int strLen = str.length();
				if (strLen > 15)
				{
					char chars[] = str.toCharArray();
					if (chars[14] != '*')
					{
						int adjacentSpaces = 0;
						for (int chIdx = 6; chIdx < strLen; chIdx++)
						{
							adjacentSpaces = (chIdx >= 29 && chars[chIdx] == ' ' ? adjacentSpaces + 1 : 0);
							if (adjacentSpaces == 2)
							{
								break; // Now we are in comment space...
							}
							
							if (chars[chIdx] == '&')
							{
								chars[chIdx] = '+';
							}
						}
						
						str = new String(chars);
					}				
				}
				
				writer.write(str);
				writer.newLine();
			}
			 
			writer.close(); 
		}
        catch(Exception ex)
        {
            ex.printStackTrace();
        }				
	}

	static void addRowToTape(String tapePath, String rowStr)
	{
		// If tapefile doesn't exist or is empty, bail out
		File tmpFile = new File(tapePath);
		if(!tmpFile.exists() || tmpFile.isDirectory() || tmpFile.length() == 0)
		{
			return;
		}
		
		try
		{
			RandomAccessFile file = new RandomAccessFile(new File(tapePath), "rws");
			
			int len = (int)file.length();
			
			byte[] buffer = new byte[len];
			file.readFully(buffer);
			
			int lineCount = 0;
			for (int idx = 0; idx < len; idx++) 
			{
				if (buffer[idx] == '\n') 
				{
					lineCount++;
				}
			}
 
			int curLine = 0;
			int buffIdx = 0;
			for (; buffIdx < len; buffIdx++) 
			{
				if (buffer[buffIdx] == '\n') 
				{
					if(++curLine == lineCount - 1)
					{
						file.seek(0);
						file.write(buffer, 0, ++buffIdx);	
						break;
					}
				}
			}
			
			rowStr = rowStr.concat("\n");
			file.writeBytes(rowStr);
			
			file.write(buffer, buffIdx, len - buffIdx);

			file.close();
		}
        catch(Exception ex)
        {
            ex.printStackTrace();
        }		
	}

    static ArrayList<String> buildCommand(boolean forDeckOrTape) throws IOException
    {		
        ArrayList<String> command = new ArrayList<String>();

		command.add(AssemblerOptions.assemblerPath);

		if(forDeckOrTape)
		{
			if (AssemblerOptions.listing) 
			{
				command.add("-l");			
				command.add(AssemblerOptions.listingPath);
			}

			if (AssemblerOptions.object) 
			{
				command.add("-o");
				command.add(AssemblerOptions.objectPath);
			}

			if (AssemblerOptions.diagnostic) 
			{			
				command.add("-d");
				command.add(AssemblerOptions.diagnosticPath);
			}

			if (AssemblerOptions.deckEncoding)
			{
				command.add("-e");

				if(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH))
				{
					command.add("S");
				}
				else if(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_A))
				{
					command.add("A");
				}
				else if(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_H))
				{
					command.add("H");
				}
				else if(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_PRINT))
				{
					command.add("?");
				}
				else
				{
					command.add("");
				}
			}
		}
		else 
		{
			command.add("-t");
			command.add(AssemblerOptions.tapePath);

			if (AssemblerOptions.tapeEncoding)
			{
				command.add("-e");

				if(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH))
				{
					command.add("S");
				}
				else if(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_A))
				{
					command.add("A");
				}
				else if(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_H))
				{
					command.add("H");
				}
				else
				{
					command.add("");
				}
			}
		}
		
		if (AssemblerOptions.boot) 
		{
            command.add("-b");
			
			if(AssemblerOptions.bootLoader == AssemblerOptions.BOOT_IBM)
			{
				switch(AssemblerOptions.coreSize)
				{
					case AssemblerOptions.SIZE_1400:
						command.add("I1");
						break;

					case AssemblerOptions.SIZE_2000:
						command.add("I2");
						break;

					case AssemblerOptions.SIZE_4000:
						command.add("I4");
						break;
				
					case AssemblerOptions.SIZE_8000:
						command.add("I8");
						break;

					case AssemblerOptions.SIZE_12000:
						command.add("Iv");
						break;

					case AssemblerOptions.SIZE_16000:
						command.add("Ix");
						break;
				}
			}
			else if(AssemblerOptions.bootLoader == AssemblerOptions.BOOT_VAN_1)
			{
				command.add("B");
			}
			else if(AssemblerOptions.bootLoader == AssemblerOptions.BOOT_VAN_2)
			{
				command.add("V");
			}	
        }

        if (AssemblerOptions.macro) 
		{
            for (String macro : AssemblerOptions.macros.split(";")) 
			{
                command.add("-m");
                command.add(macro);
            }
			
            for (String path : AssemblerOptions.macroPath.split(";")) 
			{
                command.add("-I");
                command.add(path);
            }
        }

        if (AssemblerOptions.codeOk) 
		{
            command.add("-a");
        }

        if (AssemblerOptions.interleave) 
		{
            command.add("-i");
        }

        if (AssemblerOptions.store) 
		{
            command.add("-L");
        }

        if (AssemblerOptions.dump) 
		{
            command.add("-s");
        }

        if (AssemblerOptions.page) 
		{
            String pageLength = AssemblerOptions.pageLength;
            if (pageLength.length() > 0) 
			{
                command.add("-p");
			    command.add(pageLength);
            }
        }

        if (AssemblerOptions.trace) 
		{
            StringBuilder letters = new StringBuilder(3);

            if (AssemblerOptions.traceLexer) 
			{
                letters.append('l');
            }
			
            if (AssemblerOptions.traceParser) 
			{
                letters.append('p');
            }
			
            if (AssemblerOptions.traceProcess) 
			{
                letters.append('P');
            }
			
            if (letters.length() > 0) 
			{
                command.add("-T");
                command.add(letters.toString());
            }
        }

        if (AssemblerOptions.extras) 
		{
            int flag = 0;
			
            if (AssemblerOptions.extrasEx) 
			{
                flag += 1;
            }
			
            if (AssemblerOptions.extrasEnd) 
			{
                flag += 2;
            }
			
            if (AssemblerOptions.extrasQueue) 
			{
                flag += 4;
            }
			
            if (AssemblerOptions.extrasReloader) 
			{
                flag += 8;
            }
			
            if (flag > 0) 
			{
                command.add("-X");
                command.add("" + flag);
            }
        }
				
		String sourcePath = RopeUtils.copyFile(AssemblerOptions.sourcePath, false);

		if (userPrefs.getBoolean("convertPlusToAmpersand", true))
		{
			convertPlusToAmpInSource(sourcePath);
		}
		
        command.add(sourcePath);
		
		String commandStr = "";
		for(int idx = 0; idx < command.size(); idx++)
		{
			if(idx < command.size() - 1)
			{
				commandStr = commandStr.concat(command.get(idx) + " ");
			}
			else
			{
				commandStr = commandStr.concat(command.get(idx));
			}
		}
		
        return command;
    }
		
	static Boolean buildAssembly() throws IOException
	{
		String[] args = AssemblerOptions.command.toArray(new String[0]);
		
		if(!RopeUtils.checkBuildArguments(args))
		{
			String message = "Assembly command arguments are invalid.\nCheck the lenght of source file path is no more than 110 characters.";
			JOptionPane.showMessageDialog(null, message, "ROPE", JOptionPane.ERROR_MESSAGE);
			return false;
		}

		args[0] = AssemblerOptions.assemblerPath;
		process = Runtime.getRuntime().exec(args);
		stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));

		// Wait for the process to complete
		try { process.waitFor(); }
		catch(Exception ex) {}

		// Remove the temporary source file
		File sourceFile = new File(args[args.length - 1]);
		if(sourceFile != null)
		{
			sourceFile.delete();
		}
		
		return true;
	}

	static Boolean buildTape() throws IOException
	{
		String[] tapeArgs = buildCommand(false).toArray(new String[0]);
		
		if(!RopeUtils.checkBuildArguments(tapeArgs))
		{
			String message = "Build command arguments for tape file are invalid.\nCheck the lenght of source file path is no more than 110 characters.";
			JOptionPane.showMessageDialog(null, message, "ROPE", JOptionPane.ERROR_MESSAGE);
			return false;
		}
		
		process = Runtime.getRuntime().exec(tapeArgs);
		stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));

		// Wait for the process to complete
		try { process.waitFor(); }
		catch(Exception ex) {}

		// Remove the temporary source file
		File sourceFile = new File(tapeArgs[tapeArgs.length - 1]);
		if(sourceFile != null)
		{
			sourceFile.delete();
		}
	
		return true;
	}

	static Boolean buildDeck() throws IOException
	{
		String[] deckArgs = buildCommand(true).toArray(new String[0]);
		
		if(!RopeUtils.checkBuildArguments(deckArgs))
		{
			String message = "Build command arguments for deck file are invalid.\nCheck the lenght of source file path is no more than 110 characters.";
			JOptionPane.showMessageDialog(null, message, "ROPE", JOptionPane.ERROR_MESSAGE);
			return false;
		}

		process = Runtime.getRuntime().exec(deckArgs);
		stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));

		// Wait for the process to complete
		try { process.waitFor(); }
		catch(Exception ex) {}
		
		// Remove the temporary source file
		File sourceFile = new File(deckArgs[deckArgs.length - 1]);
		if(sourceFile != null)
		{
			sourceFile.delete();
		}
		
		return true;
	}
}
